#### 1.网络框架

网络框架基于alamofire二次封装

详见 common/http包下的内容

我所做的只是对请求的参数封装

HttpClient.swift:该对象用于做url管理和请求参数封装

##### 初始化
```swift
let httpClient = HttpClient(baseUrl:DataManager.shareInstance.baseUrlCms,headers:["X-Requested-With":"XMLHttpRequest"])
```

##### 调用

```swift
httpClient.request(url: "user/{userId}", method: .post, pathParams: ["userId":userId ], params: ["password":password])
```

该方法会返回Alamofire的 DataRequest对象

再使用ResponseJsonHandle.swift中extends的两个方法来解析返回值

success回调直接返回给你整个模型 
```swift
public func responseModel&lt;T:HandyJSON&gt;( success:@escaping ((T)-&gt;()),failure:@escaping ((Int?,Error)-&gt;()) )
```

与上面方法的区别是,这个方法每次请求成功会存缓存,readCache是否读取,还提供了本次success回调是否为缓存的判断
```swift
public func responseModelAndCache<T:HandyJSON>( readCache:Bool,success:@escaping ((T,Bool)->()),failure:@escaping ((Int?,Error)->()) )
```

##### 提供一个完整的例子

```swift
httpClient.request(url: "user/{userId}",
                    method: .post,
                    pathParams: ["userId":userId ],
                    params: ["password":password])
.responseModelAndCache(readCache:true ,success: { (result:Result<User>,isCache:Bool) in
  	}, failure: {statusCode,error in 
 })
```




#### 2.StateTableView

我提供了个 自带默认(也可自定义)的head foot(基于mjrefresh), emtpyview loadingview errorview的tableview

详见component/tableview/StateTableview 和他旁边的state包(放默认cover)

我默认在emptyview和errorview中加入了点击事件 点击完会调用下拉刷新

在你传进来cover view中你也可以在上面添加 按钮和事件

关于自定义tableview cover和head的例子在demo包下 StytleTableDemoVC.swift





1.自定义全局cover 

a.直接修改 cover包下的xib

b.修改statetableview.swift下 的方法

 func setUpState()

2.自定义部分页面的cover
```swift
 self.tableView.setEmptyView(view:view ) 
 self.tableView.setLoadView(view:view ) 
 self.tableView.setErrorView(view:view ) 
```

初始化这个tableview之后

不论是否要自定义cover或者head foot

都需要在自定义之后调用

 ```swift
 self.tableView.setUpState()
 ```



3自定义全局head foot(基于mjrefresh)

修改statetableview.swift下 的方法
```swift
private func useDefaultHeaderStyle()
private func useDefaultFooterStyle()
```

4自定义部分head foot 
```swift
self.tableView.setRefreshHeader(refreshHeader: MJRefreshNormalHeader())
self.tableView.setLoadMoreFooter(loadMoreFooter: MJRefreshAutoNormalFooter())
```



#### 3业务层service        

viewcontroller->service->服务器

我的service用于放网络请求的地方

向上层viewcontroller只暴露两个回调 success和fail

详见demo-SocailAppService.swift

做了一个规范

由于一个app的服务端可能分布于多个系统,如果服务端的返回值规则不同,那就更坑了

所以我写了多个返回值模型 和多个service做拆分

比方说我工程里的 Result<T> CMSResult<T> SociaResult<T>

还有SocailAppService和CmsService  具体用法参见SocailAppService.swift



#### 4 mock数据

一般来说服务端和客户端的开发是并行的

所以通常会采用mock数据的方式来进行模拟接口联调

有的人采取工具自己部署一个服务器,然后把写死的json数据丢在里面

**but** **我采取的方案是** 把json字符串放在本地,通过mockService去读取这个文本 

##### 关于mock

mock的情况其实有两种

**1.服务端写好接口文档,返回值是已知的情况**

那么大胆使用我的方案 在xxxService中调用mockService(详见SocailAppService.swift)

等服务端接口做好了 改成指向网络的请求 ,解析部分都不需要改了

**2.接口文档不确定,服务端都没设计好返回值是啥**

你可以根据页面上的元素 比如说 name title cover 之类的 判断出可能存在的字段

并自己定义好viewmodel,使用这个viewmodel自己编造出json数据联调清楚

等服务端接口出来之后,你在解析的时候可以将 服务端返回的原始model转成 你的viewModel

因为viewModel已经和界面联调好了,所以界面那块就不需要动了



#### BaseViewController

没什么内容可以先看看[源码](https://github.com/manondidi/swiftArch/blob/master/swiftArch/common/basePage/BaseViewController.swift)和[demo](https://github.com/manondidi/swiftArch/blob/master/swiftArch/demo/DemoViewController.swift)

我在BaseViewController 上盖上了 loading error  empty的cover 并提供了自定义的方法

1.自定义全局的cover

a.修改common/component/pageState下的几个界面 这些是我放的默认的

b.修改baseviewcontroller中的方法 把自己的view传进去,因为在基类中修改 所以全局都修改了

```
func setStateManagerView(sateManager:PageSateManager){//子类重写这个方法去自定义几种View的样式
            //  stateManager?.setLoadView(view: )
 }
```



2.定制页面的cover

在子类中重写 做到单独页面的配置

```
func setStateManagerView(sateManager:PageSateManager){//子类重写这个方法去自定义几种View的样式
            //  stateManager?.setLoadView(view: )
    }
```



你可以在子类的viewcontroller中调用 展示各种cover

```
self.showContent() 
self.showEmpty()
self.showError()
self.showLoading()
```

我在errorview上加了点击事件 如果点击了会回调viewcontroller中的onReload()方法

需要用户重写 这些我的demo中都有写



### PagingViewController

这个viewcontroller的封装是这个框架的精华所在 

例子是demo中的PaingTalbeDemoViewController(pageNum pageSize分页,model解耦 section解耦 自动计算高度)、 PagingOffsetIdDemoViewController(offsetId分页 model解耦 自动计算高度)、FeedsDemoViewController(mock数据 model解耦 手动计算高度)

我先说下他这框架做了什么

1.继承自baseviewcontroller,在视图上盖上了一层cover

2.拥有stateTableView对象,上面写了stateTableView样式是个可以高度定制的(cover,header foot)

3.策略模式的分页计算

4.model cell完全解耦,而且还是只model 和section的完全解耦



#### 分页策略:我的分页规则是一个对象

客户端通常分页规则的做法 

1.要么是纯手动计算 完全不封装(太麻烦)

2.在基类中去计算(如果服务端分页有多个规则,那么就需要写多种基类)





to be continue















​    

`







​    



